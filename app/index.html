<!DOCTYPE html>
<html>
<head>
  <title>smolBSD VMs</title>
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
  <style>
    #app { max-width: 50%; }
    .blinking {
      animation: blink 1s infinite;
    }
    @keyframes blink {
      50% {
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <div id="app" class="container mt-5">
    <h1>smolBSD VMs</h1> 
    <ul class="list-group">
      <li v-for="(vm, vmName) in vmList" class="list-group-item d-flex justify-content-between align-items-center">
        <div>{{ vmName }}</div>
        <div class="btn-group" role="group" aria-label="Actions">
          <button :id="`button-${vmName}`"
              :class="['btn', 'btn-sm', 'me-2', vm.status === 'stopped' ? 'btn-success' : 'btn-danger']"
              @click="toggleVM(vmName)">
            {{ vm.status === 'running' ? 'stop' : 'start' }}
          </button>
          <button class="btn btn-sm btn-light me-2" @click="editVM(vmName)">‚úèÔ∏è</button>
          <button class="btn btn-sm btn-light me-2" @click="deleteVM(vmName)">üóëÔ∏è</button>
        </div>
      </li>
      <li class="list-group-item">
        <div class="d-flex justify-content-between align-items-center">
          <div>new vm</div>
          <button class="btn btn-sm" :class="showInputs ? 'btn-danger' : 'btn-primary' " @click="toggleInputs">
            {{ showInputs ? 'cancel' : 'create' }}
          </button>
        </div>
        <div v-if="showInputs" class="mt-2">
          <div class="input-group">
            <input v-model="VM.name" type="text" class="form-control" placeholder="VM Name" aria-label="VM Name">
          </div>
          <div class="input-group">
            <select v-model="VM.img" id="imageSelect" class="form-select">
              <option v-for="image in images" :key="image" :value="image">{{ image }}</option>
              <option value="" disabled>Image</option>
            </select>
          </div>
          <div class="input-group">
            <select v-model="VM.kernel" id="kernelSelect" class="form-select">
              <option v-for="kernel in kernels" :key="kernel" :value="kernel">{{ kernel }}</option>
              <option value="" disabled>Kernel</option>
            </select>
          </div>
          <div class="input-group">
            <input v-model="VM.mem" type="text" class="form-control" placeholder="Memory" aria-label="Memory">
          </div>
          <div class="input-group">
            <input v-model="VM.cores" type="text" class="form-control" placeholder="Cores" aria-label="Cores">
          </div>
          <div class="input-group">
            <input v-model="VM.hostfwd" type="text" class="form-control" placeholder="Host forward" aria-label="HostFwd">
          </div>
          <div class="input-group">
            <input v-model="VM.share" type="text" class="form-control" placeholder="Shared directory" aria-label="Share">
          </div>
          <button class="btn btn-success btn-sm mt-2" @click="createVM">save</button>
        </div>
      </li>
    </ul>
  </div>

  <script>
    const app = Vue.createApp({
      data() {
        return {
          vmList: {},
          showInputs: false,
          VM: {
            name: '',
            img: '',
            kernel: '',
            mem: '',
            cores: '',
            hostfwd: '',
            share: '',
          },
          images: [],
          kernels: []
        };
      },
      methods: {
        toggleInputs() {
          this.showInputs = !this.showInputs;
        },
        getVMList() {
          fetch('/vmlist')
            .then(response => response.json())
            .then(data => {
              this.vmList = data;
            })
            .catch(error => console.error('Error fetching VM list:', error));
        },
        getImages() {
          return fetch('/getimages')
            .then(response => response.json())
            .then(data => {
              this.images = data;
            })
            .catch(error => console.error('Error fetching images:', error));
        },
        getKernel() {
          return fetch('/getkernels')
            .then(response => response.json())
            .then(data => {
              this.kernels = data;
            })
            .catch(error => console.error('Error fetching kernels:', error));
        },
        getState(vm) {
          const state = vm.status === 'stopped'
            ? {
                 button: 'btn-success', action: 'start', status: 'stopped'
              }
            : {
                 button: 'btn-danger', action: 'stop', status: 'running'
              };
          return state;
        },
        toggleVM(vmName) {
          var state = this.getState(this.vmList[vmName]);
          const btnElement = document.getElementById(`button-${vmName}`);
          btnElement.classList.add('blinking');
          btnElement.classList.remove(state.button)
          btnElement.classList.add('btn-secondary')

          fetch(`/${state.action}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ vm_name: vmName }),
          })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              var retry = 0;
              const intervalId = setInterval(() => {
                this.getVMList(); // refresh vm statuses
                if (this.vmList[vmName].status !== data.status) {
                  state = this.getState(data);
                  btnElement.classList.remove('blinking');
                  btnElement.classList.add(state.button);
                  this.vmList[vmName].status = state.status;
                  clearInterval(intervalId);
                }
                if (retry++ > 3) {
                  btnElement.classList.remove('blinking');
                  btnElement.classList.add(state.button);
                  clearInterval(intervalId);
                }
              }, 1000);
            }
          })
          .catch(error => {
            alert(`Error: ${error.message}`);
          });
        },
        createVM() {
          if (!this.VM.name || this.VM.image || !this.VM.kernel) {
              alert(`VM name, kernel and image can't be empty`);
              return;
          }
          fetch('/saveconf', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              vm: this.VM.name,
              kernel: "kernels/" + this.VM.kernel,
              img: "images/" + this.VM.img,
              mem: this.VM.mem,
              cores: this.VM.cores,
              hostfwd: this.VM.hostfwd,
              share: this.VM.share
            })
          })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              this.getVMList();
              this.toggleInputs();
            }
          })
          .catch(error => {
            alert(`Error: ${error.message}`);
          });
        },
        deleteVM(vmName) {
          fetch(`/rm/${vmName}`, {
            method: 'DELETE',
            headers: { 'Content-Type': 'application/json' },
          })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              this.getVMList();
              alert(`VM ${vmName} deleted successfully.`);
            } else {
              alert(`Failed to delete VM: ${data.message}`);
            }
          })
          .catch(error => {
            alert(`Error deleting VM: ${error.message}`);
          });
        },
        editVM(vmName) {
          this.VM.name = vmName;
          this.VM.kernel = this.vmList[vmName].kernel.split("/")[1];
          this.VM.img = this.vmList[vmName].img.split("/")[1];
          this.VM.mem = this.vmList[vmName].mem;
          this.VM.cores = this.vmList[vmName].cores;
          this.VM.hostfwd = this.vmList[vmName].hostfwd;
          this.VM.share = this.vmList[vmName].share;
          this.toggleInputs();
        },
      },

      mounted() {
        this.getVMList();
        this.getImages();
        this.getKernel();
      }
    });

    app.mount('#app'); // Mount the Vue app to the `#app` div
  </script>
</body>
</html>
